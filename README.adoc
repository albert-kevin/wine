= Graph adventures with wine
:toc:
:toc-title: Weeks so far
:toclevels: 1

.by Maja Petric
[caption="Grapes  ",link=https://unsplash.com/photos/vGQ49l9I4EE] 
image::https://images.unsplash.com/photo-1423483641154-5411ec9c0ddf?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1950&q=80[width=640, align="center"] 


Based on the data from https://www.kaggle.com/zynicide/wine-reviews/data[Kaggle], this repository will hold all models, thoughts, questions and code as we explore this data set on a weekly basis.

Follow along on the https://twitch.tv/neo4j_[Neo4j Twitch channel]!


[#week1]
=== Week 1 (18 May): Let's explore the data!
_Want to participate?_

* _https://www.youtube.com/watch?v=J7WHEnA-Ygg[Watch the Twitch session^]_
* _http://www.apcjones.com/arrows/#[Link to Arrows for data modelling^]_
* _https://www.kaggle.com/zynicide/wine-reviews/data[Link to the original data set^]_

So this was an exciting start to the week! Having only just found the wine data set not that much before the start of the Twitch session, it certainly was a voyage of discovery. In this session we:

* Had a look at the data set, thinking about some of the questions we might ask and insight we could discover
* Had an initial think about what might the data model look like, and some of the modelling decisions we're going to have to make over the coming weeks
* Decided upon pairing down the data set for now, and start thinking about importing that data

*Exploring the data*

First of all, let's take a sample peak at the data:
|===
|id |country |description |designation |points |price |province |region_1 |region_2 |taster_name |taster_twitter_handle |title |variety |winery 

|0
|Italy
|Aromas include tropical fruit, broom <...>
|VulkÃ  Bianco
|87
|
|Sicily & Sardinia
|Etna
|
|Kerin Oâ€™Keefe
|@kerinokeefe
|Nicosia 2013 VulkÃ  Bianco  (Etna)
|White Blend
|Nicosia

|1
|Portugal
|This is ripe and fruity,  <...>	
|Avidagos
|87
|15
|Douro
|
|
|Roger Voss
|@vossroger
|Quinta dos Avidagos 2011 Avidagos Red (Douro)
|Portuguese Red
|Quinta dos Avidagos

|2
|US
|Tart and snappy, the flavors of lime  <...>
|
|87
|14
|Oregon
|Willamette Valley
|Willamette Valley
|Paul Gregutt
|@paulgwineÂ
|Rainstorm 2013 Pinot Gris (Willamette Valley)
|Pinot Gris
|Rainstorm
|===

We'll probably find having a definition of the headers helpful for some of the less obvious fields!

[cols="1,4",width="75%"]
|===
|Header | Description

|<id>
|The row id of the data set

|country 
|The country that the wine is from

|description 
|Description used to describe the tasting features of the wine

|designation 
|The vineyard within the winery where the grapes that made the wine are from. A winery may have more than one vineyard

|points 
|The number of points WineEnthusiast rated the wine on a scale of 1-100

|price 
|The cost for a bottle of the wine

|province 
|The province or state that the wine is from

|region_1 
|The wine growing area in a province or state (ie Napa Valley)

|region_2 
|Sometimes there are more specific regions specified within a wine growing area (ie Rutherford inside the Napa Valley)

|taster_name 
|Name of the taster

|taster_twitter_handle 
|Taster's twitter handle

|title 
|The title of the wine review, which often contains the vintage if you're interested in extracting that feature

|variety 
|The type of grapes used to make the wine (ie Pinot Noir)

|winery 
|The winery that made the wine
|===

A very interesting data set indeed. There are some rather cool things that we can explore, such as:

* Do tasters stick to certain wines, or do they go across different grape varieties/countries?
* How do points compare to price?
* How do varities cross countries?
* We can tokenise the description - can we recommend wines based on description elements?
* ...and so many more!

*Data set challenges*

As we explored this data, a number of questions arose: 

* Could we safely make the assumption that each line represented a unique wine? Or were we looking at a wine with multiple entries becauses different reviewers reviewed it?
* Were there data duplications?
* What's the year of the wine?
* and so forth

We decided to have a quick look at the data using MS Excel. We discovered some things about the data:

* there is only one wine per reviewer, so we're not dealing with multiple reviews per wine
* there are indeed duplications in the wine, we need to resolve those
* we are going to need to do some work on the wine name - we'll need to extract the year, and also we'll want to keep the title as a wine can be across many years

As an outcome of the session, I will revise the data and removed the duplicates in the dataset. Note that we could have done this within Neo4j, but I am always a fan of cleaning the data prior to a load if it is straightforward to do so!

*Modelling*

We then turned our thoughts to modelling. Using http://www.apcjones.com/arrows[Arrows^], we took a first pass at taking all of the data elements available, and then assigning them as either node labels, relationship types, or properties on either. The first pass looked like this:

.The initial pass - getting the data down on paper!
image::img\model1.jpg[]

Whilst this is far from the finished article, this initial pass allows us to start thinking about what questions we were looking to answer, and based on that, how would we change this model. There will be other things we'll need to think about resolving too, such as:

* How are we going to manage `Province` -> `Region1` -> `Region2`? Not all wines have all those details
* How are we going to represent `Wine` (of which the title contains name wine + year), and then the `WineTitle` and it's respective `Year`?
* We've also got `Designation` to add! Where's that going?

We will visit all of these questions, and more, as we continue our wine adventure!

*Importing the data*

For now, we've got a cut-down model we're going to import (we'll import the rest in the next session!), which is the following

.Model based on partial data - slightly less contravertial!
image::img\model2.jpg[]

Based on the approaches we use below, we are dealing with some of the duplicate values for now.

*Setting indexes*

As we would expect `Winery` and `Country` to be unique names, we are going to be setting some indexes to allow use to `MERGE` as we load the new data. `MERGE` behaves like a `CREATE` if the data doesn't already exist, and a `MATCH` if it does. You can read more about `MERGE` in https://neo4j.com/docs/cypher-manual/current/clauses/merge/[the documentation^].

For now, we're going to assume that `Province` is also unique, and we'll set an index on a property for that too. Not the end of the world we've we're wrong - we'll just correct the data later. All part of the journey.

I suggest you enable https://neo4j.com/developer/neo4j-browser/#browser-tips[multi statement query editor^] in browser as we start to do multiple queries in a row!

To set the indexes, run the following in Neo4j Browser:

----
CREATE INDEX ON :Winery(name);
CREATE INDEX ON :Province(name);
CREATE INDEX ON :Country(name);
----

*Dealing with null values*

So we discovered some null values in our data! We have some decisions to make. Do we want to skip values if they have a null, or do we want to set a default value? For the purposes of Country, Province and Winery, we are going to want to set some sort of value. Either we can later on extrapolate the information and correct it, or we are getting useful information by knowing it does not exist. So for this scenario we are going to stick with 'No Country', 'No Province' and 'No Winery' as our default options.

There are a number of ways we can deal with null values, and in this instance, I'm going to use the `FOREACH - IN CASE WHEN` trick. We are going to be combining `FOREACH` to allow us to do a `MERGE`, and `CASE` to check for nulls and set a default. I'm still looking for any content talking about this trick, and I'll update this document when I find it!

Loading the nodes and relationships can be memory hungry, so I am going to load the data in two passes. First of all, let's load all the nodes:
----
:auto //add this line if you're using Neo4j Browser
USING PERIODIC COMMIT 1000
LOAD CSV WITH HEADERS FROM 'https://github.com/lju-lazarevic/importdata/blob/master/winemag-data-130k-v3.csv?raw=true' AS row
FOREACH (i IN 
    CASE WHEN row.country IS NOT NULL 
         THEN [row.country] 
         ELSE ["No Country"] 
    END | MERGE (c:Country {name:i}))
FOREACH (i IN 
    CASE WHEN row.province IS NOT NULL 
         THEN [row.province] 
         ELSE ["No Province"] 
    END | MERGE (p:Province {name:i}))
FOREACH (i IN 
    CASE WHEN row.winery IS NOT NULL 
         THEN [row.winery] 
         ELSE ["No Winery"] 
    END | MERGE (w:Winery {name:i}))
----

Now we need to add the relationships between country, province and winery. I'm sure there's a prettier way to do this, which I will update when I think of it! For now, we also need to think about those null values again when we're doing the second pass:
----
:auto //add this line if you're using Neo4j Browser
USING PERIODIC COMMIT 1000
//:auto
//USING PERIODIC COMMIT 1000
LOAD CSV WITH HEADERS FROM 'https://github.com/lju-lazarevic/importdata/blob/master/winemag-data-130k-v3.csv?raw=true' AS row
WITH 
    CASE row.country 
        WHEN null 
        THEN "No Country" 
        ELSE row.country 
    END AS country,
    CASE row.province 
        WHEN null 
        THEN "No Province" 
        ELSE row.province 
    END AS province, 
    CASE row.winery 
        WHEN null 
        THEN "No Winery" 
        ELSE row.winery 
    END AS winery
MATCH (c:Country {name:country}), 
    (p:Province {name:province}), 
    (w:Winery {name:winery})
MERGE (w)-[:FROM_PROVENCE]->(p)
WITH p,c
MERGE (p)-[:PROVINCE_COUNTRY]->(c)
----

And that's the data in! As we've been using `MERGE`, that will take care of any duplicate values, so we don't need to worry about those.

*What next?*

Phew! So we've got some data in. I'll leave it to you, dear reader, to think what questions you might ask of the data. I'll suggest the following to get you started, and we'll cover them in the next session:

* Which countries have the most wineries?
* Are there any wineries across different countries?
* Which wineries are across multiple provinces?

I would love to hear what interesting discoveries you have also found. Let me know during the session!

See you on the 1st June!

[#week2]
=== Week 2 (30 May - 9am PDT, 12pm EDT, 5pm BST, 6pm CEST): Importing the data, asking some questions, revising our data model


.by Tim Mossholder
[caption="Vineyard and Hills  ",link=https://unsplash.com/photos/KDlLiCL7XPk, align="center"] 
image::https://images.unsplash.com/photo-1464036388609-747537735eab?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1950&q=80[width=640, align="center"] 

https://twitch.tv/neo4j_[Neo4j on Twitch!^]

_Want to participate?_

* _Download and install http://neo4j.com/download[Neo4j Desktop^]_
* _Create a new project in Neo4j Desktop called wine, and add a database. You may find https://neo4j.com/developer/neo4j-desktop/[this developer guide^] helpful_
* _Complete the steps for Week 1 to load the data_

Can't make the session? Not to worry, the recording will be on the https://youtube.com/neo4j[Neo4j YouTube channel^] soon after.

This week was an interesting installment! We spent the first part of the session walking through the rationale behind the load queries for the data. As you may recall we had some duplicates to deal with, so we made some decisions, such as assuming that all wineries and provinces has unique names, and we imported the data.

I also posed some questions to you all to ask of this data, as a reminder, the questions were:

* Which countries have the most wineries?
* Are there any wineries across different countries?
* Which wineries are across multiple provinces?

As well as using Cypher to answer the questions, we also had a brief look at the data using Neo4j Bloom. For those of you who have not come across Bloom before, it's a near natural language visualisation tool for graphs. You can read more about it https://medium.com/neo4j/bloom-ing-marvellous-a2be0c3702bb[here^].

So, onto those queries!

.Which countries have the most wineries?
----
MATCH path=(w:Winery)-[:FROM_PROVENCE]->(p:Province)-[:PROVINCE_COUNTRY]->(c:Country)
RETURN c.name AS Country, count(DISTINCT w) AS Total 
ORDER BY Total DESC
----

.Which wineries are across multiple provinces?
----
MATCH (w:Winery)-[:FROM_PROVENCE]->(p:Province)
WITH w, COLLECT(p.name) AS Provinces, count(p) AS Total
RETURN w.name AS Winery, Provinces, Total 
ORDER BY Total DESC
----

So, having had a look at that data, we then decided to add more data. Again, we're going to leave the sticky matter of how to deal with regions for now. We decided we'd add `Taster`, `Designation` and `Variety`, as well as the `Wine` itself. If you recall, `Wine` name also contained the year - and we'll probably want to extract that. But for now, we'll import it as is.

.The expanded data model that now includes Designation, Taster, Wine and Variety
image::img\model3.jpg[]

First of all, we need to set some indexes. We do this because this will allow us to search for data faster by using an index look up on properties of interest rather than doing a full database scan. It's also super helpful if we're using `MERGE`, again for the same reason.

.Set the required indexes
----
//indexes for additional data
CREATE INDEX ON :Wine(id);
CREATE INDEX ON :Taster(name);
CREATE INDEX ON :Variety(name);
CREATE INDEX ON :Designation(name);
----

And now we can load the data. As before, we will do two passes of this, one to create the nodes, and then the second pass to create the relationships. You will notice in the second pass we also search for the `Winery` node - this is so that we can connect it up to `Wine`!

.Loading the `Designation`, `Taster`, `Variety` and `Wine` nodes. Note that we use `CREATE` for `Wine` - that's because we expect all instances to be unique, so we can just create them
----
:auto //add this line if you're using Neo4j Browser
USING PERIODIC COMMIT 1000
LOAD CSV WITH HEADERS FROM 'https://github.com/lju-lazarevic/importdata/blob/master/winemag-data-130k-v3.csv?raw=true' AS row
FOREACH (i IN
    CASE WHEN row.designation IS NOT NULL
         THEN [row.designation]
         ELSE ["No Designation"]
    END | MERGE (d:Designation {name:i}))
FOREACH (i IN
    CASE WHEN row.taster_name IS NOT NULL
         THEN [row.taster_name]
         ELSE ["No Taster"]
    END | MERGE (t:Taster {name:i}))
FOREACH (i IN
    CASE WHEN row.variety IS NOT NULL
         THEN [row.variety]
         ELSE ["No Variety"]
    END | MERGE (v:Variety {name:i}))
CREATE (w:Wine {id:row.id, title:row.title})
----

.And following up with creating the relationships. You will notice all of the relationship types are `CREATE`, this is because they all join onto `Wine`, which as we said previously, we assume to be unique for all entries.
----
:auto //add this line if you're using Neo4j Browser
USING PERIODIC COMMIT 1000
LOAD CSV WITH HEADERS FROM 'https://github.com/lju-lazarevic/importdata/blob/master/winemag-data-130k-v3.csv?raw=true' AS row
WITH
    CASE row.designation
        WHEN null
        THEN "No Designation"
        ELSE row.designation
    END AS designation,
    CASE row.taster_name 
        WHEN null
        THEN "No Taster"
        ELSE row.taster_name 
    END AS taster,
    CASE row.variety
        WHEN null
        THEN "No Variety"
        ELSE row.variety
    END AS variety,
    CASE row.winery
        WHEN null
        THEN "No Winery"
        ELSE row.winery
    END AS winery,
    row.id as id
MATCH (d:Designation {name:designation}),
    (t:Taster {name:taster}),
    (v:Variety {name:variety}),
    (w:Wine {id:id}),
    (win:Winery {name:winery})
CREATE (w)-[:FROM_WINERY]->(win)
CREATE (w)-[:HAS_VARIETY]->(v)
CREATE (t)-[:RATES_WINE]->(w)
CREATE (w)-[:HAS_DESIGNATION]->(d)
----

Excellent! So we've got that data in, and now we can think about some different questions we can ask. For example:

* Who is the most prolific wine taster?
* How many wine varieties contain the word 'red'?

.Querying for the most prolific wine taster
----
//Most prolific taster
MATCH (t:Taster)
WHERE t.name <> "No Taster"
WITH t
MATCH (t)-[:RATES_WINE]->(w:Wine)-[:HAS_VARIETY]->(v:Variety)
WITH t, count(w) AS total, COLLECT(DISTINCT v.name) AS varieties
RETURN t.name AS taster, varieties, total 
ORDER BY total DESC
----

.Finding all the varieties that contain the word 'red' in them
----
MATCH (v:Variety)
WHERE tolower(v.name) CONTAINS 'red'
RETURN v.name 
ORDER BY v.name
----

Have a go at some other questions yourself! You can always use Bloom to help think about what you might want to investigate too. If you can think of a question that you're not sure how to write a query for, we can cover it in the session.

[#week3]
=== Week 3 (6 June - 9am PDT, 12pm EDT, 5pm BST, 6pm CEST): Let's tackle those wine years!

.by Maksym Kaharlytskyi
[caption="Four glasses of wine  ",link=https://unsplash.com/photos/3uJt73tr4hI, align="center"] 
image::https://images.unsplash.com/photo-1568213816046-0ee1c42bd559?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1952&q=80[width=640, align="center"] 

https://twitch.tv/neo4j_[Neo4j on Twitch!^]

_Want to participate?_

* _Download and install http://neo4j.com/download[Neo4j Desktop^]_
* _Create a new project in Neo4j Desktop called wine, and add a database. You may find https://neo4j.com/developer/neo4j-desktop/[this developer guide^] helpful_
* _Complete the steps for Week 1 & 2 to load the data_

So for this week, I am thinking let's think about pulling out the year from the Wine name - and yes, we'll do a bit more graph refactoring - however, we are going to make physical changes to the data, rather than do this by import!

Also, we can start to have a think about what are we going to do with all those wine descriptions too.

[#week4]
=== Week 4 (13 June - 9am PDT, 12pm EDT, 5pm BST, 6pm CEST): Based on the outcome of week 3